
---

# 💻 300CIS017 Programación Orientada a Objetos 2025-01  <!-- omit in toc -->
![Version](https://img.shields.io/badge/version-1.0-blue)
[![License: CC BY-NC-ND 4.0](https://img.shields.io/badge/License-CC%20BY--NC--ND%204.0-lightgrey.svg?color=#007ec6)](https://creativecommons.org/licenses/by-nc-nd/4.0/)

---


# 🌟 Tema 2: El lenguaje C++ - Parte 2<!-- omit in toc -->

---

### 🎥 Videos que inspiraron este tema:

<table style="border-collapse: collapse; width: 100%; border: none; margin: 10px 0;">
  <tr>
    <td style="text-align: center; padding: 5px; border: none;">
      <a href="https://www.youtube.com/watch?v=Hh9yZWeTmVM">
        <img src="img/vid4.png" alt="The Beginning - OOR" width="150">
      </a>
      <br>
      <span style="font-size: 12px; margin-top: 5px; display: inline-block;">The Beginning<br>OOR</span>
    </td>
    <td style="text-align: center; padding: 5px; border: none;">
      <a href="https://www.youtube.com/watch?v=Ibp_y21LHJY">
        <img src="img/vid5.png" alt="Push Back - OOR" width="150">
      </a>
      <br>
      <span style="font-size: 12px; margin-top: 5px; display: inline-block;">Push Back<br>OOR</span>
    </td>
  </tr>
</table>

---

### 💻 Creado por   

Profesorcito © 2025

---

### 🎶 Dedicado a 

[Takahiro Moriuchi](https://es.wikipedia.org/wiki/Takahiro_Moriuchi) (Taka) 🎤

---

En este capítulo, aprenderemos sobre **bucles (`for`, `while`, `do-while`)**, **arreglos**, **punteros**, **referencias**, **funciones** y **asignación dinámica de memoria**, conceptos clave para escribir código eficiente y estructurado. 🚀

---

### **Tabla de Contenido**

- [1. **Estructuras de Repetición**](#1-estructuras-de-repetición)
  - [**El bucle `for`**](#el-bucle-for)
    - [🚀 **Ejemplo 1: Imprimir números del 1 al 5**](#-ejemplo-1-imprimir-números-del-1-al-5)
    - [🚀 **Ejemplo 2: Contador en decremento**](#-ejemplo-2-contador-en-decremento)
    - [🚀 **Ejemplo 3: Recorrer un array**](#-ejemplo-3-recorrer-un-array)
    - [🚀 **Ejemplo 4: Tabla de multiplicar**](#-ejemplo-4-tabla-de-multiplicar)
    - [🚀 **Ejemplo 5: Bucle infinito con `for`**](#-ejemplo-5-bucle-infinito-con-for)
    - [🚀 **Ejemplo 6: Imprimir un triángulo de asteriscos con `for` anidados**](#-ejemplo-6-imprimir-un-triángulo-de-asteriscos-con-for-anidados)
  - [**El bucle `while`**](#el-bucle-while)
    - [🚀 **Ejemplo 1: Contador del 1 al 5**](#-ejemplo-1-contador-del-1-al-5)
    - [🚀 **Ejemplo 2: Cuenta regresiva**](#-ejemplo-2-cuenta-regresiva)
    - [🚀 **Ejemplo 3: Leer hasta que el usuario ingrese un número positivo**](#-ejemplo-3-leer-hasta-que-el-usuario-ingrese-un-número-positivo)
    - [🚀 **Ejemplo 4: Sumar valores ingresados por el usuario**](#-ejemplo-4-sumar-valores-ingresados-por-el-usuario)
    - [🚀 **Ejemplo 5: Bucle infinito con `while`**](#-ejemplo-5-bucle-infinito-con-while)
  - [**El bucle `do-while`**](#el-bucle-do-while)
    - [🚀 **Ejemplo 1: Validar entrada de usuario (Básico y útil)**](#-ejemplo-1-validar-entrada-de-usuario-básico-y-útil)
    - [🚀 **Ejemplo 2: Simulador de menú interactivo**](#-ejemplo-2-simulador-de-menú-interactivo)
  - [🧩 **Problemas de Bucles Propuestos en C++**](#-problemas-de-bucles-propuestos-en-c)
  - [**Instrucciones `break` y `continue`**](#instrucciones-break-y-continue)
    - [🚀 **Ejemplo 1: Uso de `break` (Sumar solo valores positivos)**](#-ejemplo-1-uso-de-break-sumar-solo-valores-positivos)
    - [🚀 **Ejemplo 2: Uso de `continue` (Imprimir valores del 1 al 10, omitiendo el 5)**](#-ejemplo-2-uso-de-continue-imprimir-valores-del-1-al-10-omitiendo-el-5)
- [2. **Arreglos**](#2-arreglos)
  - [**Declaración de un arreglo**](#declaración-de-un-arreglo)
  - [**Inicialización de arreglos**](#inicialización-de-arreglos)
    - [🚀 **Ejemplo 1: Suma de dos matrices en C++**](#-ejemplo-1-suma-de-dos-matrices-en-c)
  - [🧩 **Problemas de Arreglos Propuestos en C++**](#-problemas-de-arreglos-propuestos-en-c)
- [3. **Punteros**](#3-punteros)
    - [**Ejemplo básico**](#ejemplo-básico)
  - [**Aritmética de punteros**](#aritmética-de-punteros)
    - [**Operaciones básicas de aritmética de punteros**](#operaciones-básicas-de-aritmética-de-punteros)
    - [**Otras operaciones con punteros**](#otras-operaciones-con-punteros)
  - [🧩 **Problemas de Punteros Propuestos en C++**](#-problemas-de-punteros-propuestos-en-c)
- [4. **Referencias**](#4-referencias)
    - [🚀 **Ejemplo 1: Referencia a una variable**](#-ejemplo-1-referencia-a-una-variable)
  - [**Referencias constantes (`const &`)**](#referencias-constantes-const-)
    - [🚀 **Ejemplo 2: Uso de `const &`**](#-ejemplo-2-uso-de-const-)
  - [**Comparación entre referencias y punteros**](#comparación-entre-referencias-y-punteros)
- [5. **Funciones**](#5-funciones)
    - [**Ejemplo básico**](#ejemplo-básico-1)
  - [**Métodos de paso de argumentos**](#métodos-de-paso-de-argumentos)
    - [**Paso por valor**](#paso-por-valor)
    - [**Paso por referencia con punteros**](#paso-por-referencia-con-punteros)
    - [**Paso por referencia con referencias**](#paso-por-referencia-con-referencias)
  - [🧩 **Problemas de Funciones Propuestos en C++**](#-problemas-de-funciones-propuestos-en-c)
- [6. **Asignación dinámica de memoria en C++**](#6-asignación-dinámica-de-memoria-en-c)
  - [**Asignación de memoria dinámica**](#asignación-de-memoria-dinámica)
  - [**Liberación de memoria dinámica**](#liberación-de-memoria-dinámica)
  - [**Ejemplo completo: Promedios de estudiantes (Memoria dinámica)**](#ejemplo-completo-promedios-de-estudiantes-memoria-dinámica)
  - [**Versión estática (Tamaño fijo del array)**](#versión-estática-tamaño-fijo-del-array)
- [**🧮 Tarea 2 - Reto C++**](#-tarea-2---reto-c)

---

# 1. **Estructuras de Repetición**  

En programación, los **bucles** 🔄 permiten repetir instrucciones sin escribirlas múltiples veces. En C++, existen **tres tipos de bucles** fundamentales:  

## **El bucle `for`**  

Se usa cuando **se conoce de antemano** cuántas veces debe repetirse la ejecución del bloque de código.  

### Sintaxis: <!-- omit in toc -->  

```cpp
for (inicialización; condición; actualización) {
    // Bloque de código que se ejecuta en cada iteración
}
```  

📌 **Explicación de cada parte:**  
1. **Inicialización**: Se ejecuta una sola vez al inicio del bucle. Se usa para definir y asignar un valor inicial a una variable de control.  
2. **Condición**: Se evalúa antes de cada iteración. Si es `true`, el bloque de código se ejecuta; si es `false`, el bucle termina.  
3. **Actualización**: Se ejecuta al final de cada iteración y suele modificar la variable de control.  

---

### 🚀 **Ejemplo 1: Imprimir números del 1 al 5**  

```cpp
#include <iostream>
using namespace std;

int main() {
    for (int i = 1; i <= 5; i++) {  // i inicia en 1, se detiene cuando i > 5, y se incrementa en 1
        cout << "Valor: " << i << endl;
    }
    return 0;
}
```  

📌 **Salida:**  
```
Valor: 1
Valor: 2
Valor: 3
Valor: 4
Valor: 5
```  

---

### 🚀 **Ejemplo 2: Contador en decremento**  

```cpp
#include <iostream>
using namespace std;

int main() {
    for (int i = 10; i >= 1; i--) {  // i inicia en 10 y va decreciendo hasta 1
        cout << "Cuenta regresiva: " << i << endl;
    }
    return 0;
}
```  

📌 **Salida:**  
```
Cuenta regresiva: 10
Cuenta regresiva: 9
Cuenta regresiva: 8
Cuenta regresiva: 7
Cuenta regresiva: 6
Cuenta regresiva: 5
Cuenta regresiva: 4
Cuenta regresiva: 3
Cuenta regresiva: 2
Cuenta regresiva: 1
```  

---

### 🚀 **Ejemplo 3: Recorrer un array**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int numeros[] = {3, 7, 1, 9, 5};
    int tamaño = sizeof(numeros) / sizeof(numeros[0]); // Calcula el tamaño del array

    for (int i = 0; i < tamaño; i++) {  // Recorre el array usando su tamaño
        cout << "Elemento " << i << ": " << numeros[i] << endl;
    }
    return 0;
}
```  

📌 **Salida:**  
```
Elemento 0: 3
Elemento 1: 7
Elemento 2: 1
Elemento 3: 9
Elemento 4: 5
```  

---

### 🚀 **Ejemplo 4: Tabla de multiplicar**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cout << "Introduce un número: ";
    cin >> n;

    for (int i = 1; i <= 10; i++) {
        cout << n << " x " << i << " = " << (n * i) << endl;
    }

    return 0;
}
```  

📌 **Salida si el usuario ingresa `7`:**  
```
7 x 1 = 7
7 x 2 = 14
7 x 3 = 21
7 x 4 = 28
7 x 5 = 35
7 x 6 = 42
7 x 7 = 49
7 x 8 = 56
7 x 9 = 63
7 x 10 = 70
```  

---

### 🚀 **Ejemplo 5: Bucle infinito con `for`**  

```cpp
#include <iostream>
using namespace std;

int main() {
    for (;;) {  // No hay inicialización, condición ni actualización
        cout << "Esto es un bucle infinito!" << endl;
    }
    return 0;
}
```  

📌 **Esto imprimirá el mensaje infinitamente hasta que detengas el programa manualmente (`Ctrl + C` en consola).**  

---

### 🚀 **Ejemplo 6: Imprimir un triángulo de asteriscos con `for` anidados**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int filas;

    cout << "Introduce el número de filas: ";
    cin >> filas;

    for (int i = 1; i <= filas; i++) {  // Controla las filas
        for (int j = 1; j <= i; j++) {  // Controla la cantidad de asteriscos por fila
            cout << "* ";
        }
        cout << endl;  // Salto de línea para la siguiente fila
    }

    return 0;
}
```  

📌 **Salida si el usuario ingresa `5`:**  
```
* 
* * 
* * * 
* * * * 
* * * * * 
```  

---

## **El bucle `while`**  

Se usa cuando **no se conoce de antemano** cuántas veces debe repetirse la ejecución del bloque de código. El bucle continuará ejecutándose **mientras una condición sea verdadera**.

### Sintaxis: <!-- omit in toc -->

```cpp
while (condición) {
    // Bloque de código que se ejecuta en cada iteración
}
```

📌 **Explicación de cada parte:**  
1. **Condición**: Se evalúa antes de cada iteración. Si es `true`, el bloque de código se ejecuta; si es `false`, el bucle termina.  
2. **Bloque de código**: Se ejecuta una y otra vez mientras la condición siga siendo verdadera.  
3. **Cambio de estado**: Es necesario modificar alguna variable dentro del bucle para que eventualmente la condición sea `false`, evitando un bucle infinito.  

---

### 🚀 **Ejemplo 1: Contador del 1 al 5**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int contador = 1;  // Se inicia el contador en 1

    while (contador <= 5) {  // Se ejecuta mientras contador sea menor o igual a 5
        cout << "Valor: " << contador << endl;
        contador++;  // Se incrementa el contador en 1
    }

    return 0;
}
```

📌 **Salida:**
```
Valor: 1
Valor: 2
Valor: 3
Valor: 4
Valor: 5
```

---

### 🚀 **Ejemplo 2: Cuenta regresiva**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int contador = 10;

    while (contador >= 1) {  // Se ejecuta mientras contador sea mayor o igual a 1
        cout << "Cuenta regresiva: " << contador << endl;
        contador--;  // Se decrementa en 1
    }

    return 0;
}
```

📌 **Salida:**
```
Cuenta regresiva: 10
Cuenta regresiva: 9
...
Cuenta regresiva: 1
```

---

### 🚀 **Ejemplo 3: Leer hasta que el usuario ingrese un número positivo**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int numero;

    cout << "Ingresa un número positivo: ";
    cin >> numero;

    while (numero <= 0) {  // Se repite mientras el número sea negativo o cero
        cout << "El número no es positivo. Intenta de nuevo: ";
        cin >> numero;
    }

    cout << "Número válido ingresado: " << numero << endl;
    return 0;
}
```

📌 **Ejemplo de entrada y salida:**  
```
Ingresa un número positivo: -3
El número no es positivo. Intenta de nuevo: 0
El número no es positivo. Intenta de nuevo: 7
Número válido ingresado: 7
```

---

### 🚀 **Ejemplo 4: Sumar valores ingresados por el usuario**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int suma = 0, num;

    cout << "Ingresa números para sumar (0 para terminar): ";

    while (true) {  // Se repite hasta que el usuario ingrese 0
        cin >> num;
        if (num == 0) {
            break;  // Sale del bucle cuando el usuario ingresa 0
        }
        suma += num;
    }

    cout << "Suma total: " << suma << endl;
    return 0;
}
```

📌 **Ejemplo de entrada y salida:**  
```
Ingresa números para sumar (0 para terminar): 5
10
-2
3
0
Suma total: 16
```

---

### 🚀 **Ejemplo 5: Bucle infinito con `while`**  

```cpp
#include <iostream>
using namespace std;

int main() {
    while (true) {  // No hay condición de salida
        cout << "Esto es un bucle infinito!" << endl;
    }
    return 0;
}
```

📌 **Esto imprimirá el mensaje infinitamente hasta que detengas el programa manualmente (`Ctrl + C` en consola).**  

---

## **El bucle `do-while`**  

Es similar al `while`, pero **siempre ejecuta al menos una vez** el bloque de código antes de evaluar la condición.

### Sintaxis: <!-- omit in toc -->

```cpp
do {
   // Código a ejecutar en cada iteración
} while (condición);
```

📌 **Explicación de cada parte:**  
1. **Bloque de código**: Se ejecuta **una vez antes de evaluar** la condición.  
2. **Condición**: Se evalúa después de la primera ejecución. Si es `true`, el bucle continúa; si es `false`, el bucle termina.  

---

### 🚀 **Ejemplo 1: Validar entrada de usuario (Básico y útil)**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int numero;

    do {
        cout << "Ingresa un número positivo: ";
        cin >> numero;

        if (numero <= 0) {
            cout << "Error: el número debe ser positivo." << endl;
        }

    } while (numero <= 0);  // Repite mientras el número no sea positivo

    cout << "Número válido ingresado: " << numero << endl;
    return 0;
}
```

📌 **Ejemplo de entrada y salida:**  
```
Ingresa un número positivo: -4
Error: el número debe ser positivo.
Ingresa un número positivo: 0
Error: el número debe ser positivo.
Ingresa un número positivo: 7
Número válido ingresado: 7
```

> [!TIP]  
> Te estarás preguntando cuándo se usa `do-while` o por qué existe en primer lugar. La razón es que garantiza que el usuario vea el mensaje al menos una vez, sin importar la condición. Además, si el usuario ingresa un valor correcto desde el inicio, el bucle solo se ejecuta una vez, evitando iteraciones innecesarias.

---

### 🚀 **Ejemplo 2: Simulador de menú interactivo**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int opcion;

    do {
        // Mostrar opciones
        cout << "\nMENÚ DE OPCIONES" << endl;
        cout << "1. Saludar" << endl;
        cout << "2. Mostrar fecha" << endl;
        cout << "3. Salir" << endl;
        cout << "Selecciona una opción: ";
        cin >> opcion;

        // Ejecutar la opción seleccionada
        switch (opcion) {
            case 1:
                cout << "¡Hola! Espero que estés teniendo un gran día." << endl;
                break;
            case 2:
                cout << "Hoy es un gran día para programar en C++." << endl;
                break;
            case 3:
                cout << "Saliendo del programa..." << endl;
                break;
            default:
                cout << "Opción no válida, intenta de nuevo." << endl;
        }

    } while (opcion != 3);  // Repite mientras el usuario no seleccione "Salir"

    return 0;
}
```

📌 **Ejemplo de entrada y salida:**  
```
MENÚ DE OPCIONES
1. Saludar
2. Mostrar fecha
3. Salir
Selecciona una opción: 1
¡Hola! Espero que estés teniendo un gran día.

MENÚ DE OPCIONES
1. Saludar
2. Mostrar fecha
3. Salir
Selecciona una opción: 2
Hoy es un gran día para programar en C++.

MENÚ DE OPCIONES
1. Saludar
2. Mostrar fecha
3. Salir
Selecciona una opción: 3
Saliendo del programa...
```

---

## 🧩 **Problemas de Bucles Propuestos en C++**  

---

### 🏅 **Problema bucle01: Suma** | 🛡️ **Novato** <!-- omit in toc -->  

🔹 **Descripción:** Suma todos los números del `1` hasta `n`.  

📌 **Ejemplo:**  
```
Ingresa un número: 5
La suma es: 15
```  

> [!TIP]
> Usa un `for` para recorrer y acumular la suma.  

---

### 🏅 **Problema bucle02: Dígitos** | ⚔️ **Guerrero** <!-- omit in toc -->  

🔹 **Descripción:** Cuenta cuántos dígitos tiene un número entero.  

📌 **Ejemplo:**  
```
Ingresa un número: 12345
Tiene 5 dígitos.
```  

> [!TIP]
> Divide entre `10` en un `while` hasta que sea `0`.  

---

### 🏅 **Problema bucle03: Adivina el Número** | ⚔️ **Guerrero** <!-- omit in toc -->  

🔹 **Descripción:** Genera un número aleatorio del `1` al `100`. El usuario debe adivinarlo con pistas.  

📌 **Ejemplo:**  
```
Adivina el número (1-100): 50
Es mayor. Intenta de nuevo: 75
Es menor. Intenta de nuevo: 63
¡Correcto!
```  

> [!TIP]
> Usa `rand()` y un `do-while` para repetir intentos.  

---

### 🏅 **Problema bucle04: Pirámide de Números** | 🔥 **Experto** <!-- omit in toc -->  

🔹 **Descripción:** Imprime una pirámide de números con `n` filas.  

📌 **Ejemplo si `n = 5`:**  
```
    1
   121
  12321
 1234321
123454321
```  

> [!TIP]
> Usa `for` anidados para manejar espacios y números.  

---

### 🏅 **Problema bucle05: Números Primos** | 👑 **Leyenda** <!-- omit in toc -->  

🔹 **Descripción:** Verifica si un número es **primo** o **compuesto**.  

📌 **Ejemplo:**  
```
Ingresa un número: 17
Es primo.
```  

> [!TIP]
> Usa un `for` para contar divisores.  

---

## **Instrucciones `break` y `continue`**  

En C++, las instrucciones `break` y `continue` permiten **controlar el flujo de ejecución de un bucle** de manera más flexible.  

- **`break`**: Finaliza el bucle inmediatamente, sin importar si la condición del bucle sigue siendo verdadera.  
- **`continue`**: Salta el resto del código en la iteración actual y pasa directamente a la siguiente iteración.  

---

### 🚀 **Ejemplo 1: Uso de `break` (Sumar solo valores positivos)**  

```cpp
#include <iostream>
using namespace std;

int main() {
    double suma = 0.0, valor;
    cout << "Ingresa valores uno por uno. Se sumaran mientras sean positivos." << endl;

    for (;;) { // Bucle infinito controlado con break
        cout << "Valor: ";
        cin >> valor;
        if (valor <= 0) break; // Sale del bucle si el valor es negativo o cero
        suma += valor;
    }

    cout << "Suma de los valores positivos ingresados: " << suma << endl;
    return 0;
}
```  

📌 **Salida:**  
```
Ingresa valores uno por uno. Se sumaran mientras sean positivos.
Valor: 5
Valor: 3.5
Valor: 10
Valor: -1
Suma de los valores positivos ingresados: 18.5
```  

---

### 🚀 **Ejemplo 2: Uso de `continue` (Imprimir valores del 1 al 10, omitiendo el 5)**  

```cpp
#include <iostream>
using namespace std;

int main() {
    for (int i = 1; i <= 10; i++) {
        if (i == 5) continue; // Salta la impresión del 5
        cout << "Valor: " << i << endl;
    }

    cout << "Se uso 'continue' para omitir la impresion del 5." << endl;
    return 0;
}
```  

📌 **Salida:**  
```
Valor: 1
Valor: 2
Valor: 3
Valor: 4
Valor: 6
Valor: 7
Valor: 8
Valor: 9
Valor: 10
Se uso 'continue' para omitir la impresion del 5.
```  

---

# 2. **Arreglos**  

Los **arreglos (arrays)** permiten **almacenar múltiples valores** del mismo tipo en una sola estructura, proporcionando **acceso directo a cada elemento** mediante un índice. Son útiles cuando se necesita manejar **grupos de datos homogéneos**.  

---

## **Declaración de un arreglo**  

### Sintaxis: <!-- omit in toc -->  

```cpp
tipo nombre_arreglo[tamaño];
```  

📌 **Ejemplo:** Declarar un **arreglo unidimensional de 5 elementos**.  

```cpp
#include <iostream>
using namespace std;

int main() {
    int i, a[5];

    // Leer 5 valores
    for (i = 0; i < 5; i++) {
        cout << "a[" << i + 1 << "]= ";
        cin >> a[i];
    }

    // Imprimir los valores en orden inverso
    cout << "Los números en orden inverso: ";
    for (i = 4; i >= 0; i--)
        cout << a[i] << " ";

    return 0;
}
```

📌 **Ejemplo de entrada y salida:**  
```
a[1]= 7  
a[2]= 2  
a[3]= 9  
a[4]= 4  
a[5]= 5  
Los números en orden inverso: 5 4 9 2 7  
```

---

## **Inicialización de arreglos**  

### Sintaxis: <!-- omit in toc -->  

```cpp
tipo nombre_arreglo[fila][columna] = { {valores fila 1}, {valores fila 2}, ... };
```

📌 **Ejemplos:**  

```cpp
int a[2][3] = { {1,2,3}, {4,5,6} };  
int b[2][3] = { 1,2,3,4,5 };  // El último valor se llena con 0 automáticamente  
int c[2][3] = { {1,2}, {4} }; // Los valores faltantes son 0  
```

📌 **Valores de los arreglos por fila:**  

- **Arreglo `a`**  
```
1 2 3  
4 5 6  
```

- **Arreglo `b`**  
```
1 2 3  
4 5 0  
```

- **Arreglo `c`**  
```
1 2 0  
4 0 0  
```

📌 **Ejemplo en código:**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int i, j;
    int a[2][3] = { {1,2,3}, {4,5,6} };
    int b[2][3] = { 1,2,3,4,5 };  
    int c[2][3] = { {1,2}, {4} };

    cout << "Arreglo a:" << endl;
    for (i = 0; i < 2; i++) {
        for (j = 0; j < 3; j++)
            cout << a[i][j] << " ";
        cout << endl;
    }

    cout << "Arreglo b:" << endl;
    for (i = 0; i < 2; i++) {
        for (j = 0; j < 3; j++)
            cout << b[i][j] << " ";
        cout << endl;
    }

    cout << "Arreglo c:" << endl;
    for (i = 0; i < 2; i++) {
        for (j = 0; j < 3; j++)
            cout << c[i][j] << " ";
        cout << endl;
    }

    return 0;
}
```

📌 **Salida esperada:**  
```
Arreglo a:  
1 2 3  
4 5 6  

Arreglo b:  
1 2 3  
4 5 0  

Arreglo c:  
1 2 0  
4 0 0  
```

---

> [!IMPORTANT]
> Si necesitas una estructura más flexible, usa **`std::vector`** o **`std::array`** en lugar de arreglos tradicionales. Estas estructuras forman parte de la **STL (Standard Template Library)** y ofrecen mayor seguridad y funcionalidad. Para utilizarlas, es necesario incluir las librerías correspondientes: `#include <array>` para `std::array` y `#include <vector>` para `std::vector`.
>

---

### 🚀 **Ejemplo 1: Suma de dos matrices en C++** 

```cpp
#include <iostream>
using namespace std;

int main() {
    int filas, columnas;

    // Solicitar dimensiones de la matriz
    cout << "Ingresa el número de filas: ";
    cin >> filas;
    cout << "Ingresa el número de columnas: ";
    cin >> columnas;

    int matriz1[filas][columnas], matriz2[filas][columnas], resultado[filas][columnas];

    // Leer la primera matriz
    cout << "Ingresa los valores de la primera matriz:" << endl;
    for (int i = 0; i < filas; i++) {
        for (int j = 0; j < columnas; j++) {
            cout << "Matriz1[" << i << "][" << j << "]: ";
            cin >> matriz1[i][j];
        }
    }

    // Leer la segunda matriz
    cout << "Ingresa los valores de la segunda matriz:" << endl;
    for (int i = 0; i < filas; i++) {
        for (int j = 0; j < columnas; j++) {
            cout << "Matriz2[" << i << "][" << j << "]: ";
            cin >> matriz2[i][j];
        }
    }

    // Sumar ambas matrices
    for (int i = 0; i < filas; i++) {
        for (int j = 0; j < columnas; j++) {
            resultado[i][j] = matriz1[i][j] + matriz2[i][j];
        }
    }

    // Mostrar la matriz resultante
    cout << "Matriz resultante (suma de ambas matrices):" << endl;
    for (int i = 0; i < filas; i++) {
        for (int j = 0; j < columnas; j++) {
            cout << resultado[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}
```

---

📌 **Salida:**  

```
Ingresa el número de filas: 2  
Ingresa el número de columnas: 2  

Ingresa los valores de la primera matriz:  
Matriz1[0][0]: 1  
Matriz1[0][1]: 2  
Matriz1[1][0]: 3  
Matriz1[1][1]: 4  

Ingresa los valores de la segunda matriz:  
Matriz2[0][0]: 5  
Matriz2[0][1]: 6  
Matriz2[1][0]: 7  
Matriz2[1][1]: 8  

Matriz resultante (suma de ambas matrices):  
6 8  
10 12  
```

## 🧩 **Problemas de Arreglos Propuestos en C++**  

---  

### 🏅 **Problema arreglo01: Mayor y Menor** | 🛡️ **Novato** <!-- omit in toc -->  

🔹 **Descripción:** Lee `n` números y encuentra el **mayor** y el **menor** valor del arreglo.  

📌 **Ejemplo:**  
```
Ingresa la cantidad de números: 5
Número 1: 8
Número 2: 3
Número 3: 15
Número 4: 7
Número 5: 10
Mayor: 15
Menor: 3
```  

> [!TIP]  
> Usa un `for` para recorrer el arreglo y comparar valores.  

---  

### 🏅 **Problema arreglo02: Promedio de Calificaciones** | ⚔️ **Guerrero** <!-- omit in toc -->  

🔹 **Descripción:** Dado un arreglo con `n` calificaciones, calcula el **promedio** y muestra cuáles están por encima y por debajo de la media.  

📌 **Ejemplo:**  
```
Ingresa la cantidad de calificaciones: 4
Calificación 1: 80
Calificación 2: 90
Calificación 3: 75
Calificación 4: 85
Promedio: 82.5
Por encima del promedio: 90, 85
Por debajo del promedio: 80, 75
```  

> [!TIP]  
> Usa un `for` para sumar los valores y calcular el promedio. Luego, usa un segundo `for` para imprimir las calificaciones por encima del promedio y un tercer `for` para las calificaciones por debajo de la media.  

---  

### 🏅 **Problema arreglo03: Matriz Transpuesta** | 🔥 **Experto** <!-- omit in toc -->  

🔹 **Descripción:** Dada una matriz `n x m`, genera su **matriz transpuesta**, es decir, intercambia sus filas y columnas.  

📌 **Ejemplo:**  
```
Matriz original:
1  2  3  
4  5  6  

Matriz transpuesta:
1  4  
2  5  
3  6  
```  

> [!TIP]  
> Usa dos `for` anidados para intercambiar `matriz[i][j]` por `matriz[j][i]`.  

---  

### 🏅 **Problema arreglo04: Eliminación de Duplicados** | 👑 **Leyenda** <!-- omit in toc -->  

🔹 **Descripción:** Dado un arreglo con `n` números, **elimina los duplicados** y muestra el resultado sin repetir elementos.  

📌 **Ejemplo:**  
```
Ingresa la cantidad de números: 8
Ingresa los números:
2 5 3 2 8 5 3 10

Arreglo sin duplicados: 2 5 3 8 10
```  

> [!TIP]
> Tu puedes!
> 
---

# 3. **Punteros**

Variables que contienen una dirección de memoria como su valor.

> [!IMPORTANT]  
> Los punteros en **C++** son una herramienta sumamente poderosa que permite **manipular directamente la memoria**. A diferencia de otros lenguajes de alto nivel, donde la gestión de memoria es automática, en C++ **tienes control total** sobre la asignación y liberación de memoria. Sin embargo, como se menciona en la película *Spider-Man* (2002): "[No lo olvides, un gran poder conlleva una gran responsabilidad](https://youtu.be/kfRIn8rlFgU?feature=shared&t=60)". 


Hay dos operadores importantes para los punteros:

- `&` (dirección de): devuelve la dirección del objeto dado como operando
- `*` (desreferenciar): devuelve el objeto que se encuentra en la dirección dada por el operando

### **Ejemplo básico**

```cpp
#include <iostream>

using namespace std;

int main() {
    int i = 16;
    int *pi;
    pi = &i;
    cout << *pi << endl;
    return 0;
}
```

**Salida esperada:**
```
16
```

<details><summary>👨‍🏫 Explicación</summary>

Este programa muestra cómo utilizar un puntero para acceder al valor de una variable en **C++**. A continuación, se explican los conceptos clave del código:

1. **Declaración de la variable `i` y el puntero `pi`**:
   - `int i = 16;` declara una variable entera `i` con el valor `16`.
   - `int *pi;` declara un puntero `pi` que almacenará la dirección de una variable de tipo `int`.

2. **Asignación de la dirección de `i` al puntero `pi`**:
   - `pi = &i;` asigna a `pi` la dirección de memoria de `i` utilizando el operador `&` (operador de dirección). Ahora, `pi` apunta a la ubicación en memoria donde se encuentra `i`.

3. **Desreferenciación del puntero (`*pi`)**:
   - `cout << *pi << endl;` utiliza el operador `*` (operador de desreferenciación) para acceder al valor almacenado en la dirección de memoria a la que apunta `pi`, en este caso, `16`.  
   - Es decir, `*pi` equivale a `i`, por lo que se imprime `16`.

4. **Flujo de ejecución**:
   - Se declara `i` y se le asigna `16`.
   - Se declara el puntero `pi`.
   - Se almacena la dirección de `i` en `pi`.
   - Se imprime el valor almacenado en la dirección apuntada por `pi`, que es `16`.

En resumen, este programa demuestra cómo los punteros pueden usarse para **acceder y manipular directamente la memoria** en C++, permitiendo un mayor control sobre los datos almacenados.

</details>  

## **Aritmética de punteros**

En C++, los punteros pueden usarse en expresiones aritméticas.

Esta aritmética no es solo suma o resta simple; tiene en cuenta el tamaño del tipo de dato al que apunta el puntero.

---

### **Operaciones básicas de aritmética de punteros**  

```cpp
#include <iostream>

using namespace std;

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    int *ptr = arr;
    
    // Imprimir el arreglo antes de modificarlo
    cout << "Arreglo original: ";
    for (int i = 0; i < 5; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    ptr++; // Ahora ptr apunta a arr[1]
    
    cout << "El valor al que apunta ptr (arr[1]) es: " << *ptr << endl;

    // Acceder a otros elementos usando aritmética de punteros
    cout << "El siguiente elemento es: " << *(ptr + 1) << endl; // Equivalente a arr[2]
    cout << "El elemento anterior es: " << *(ptr - 1) << endl; // Equivalente a arr[0]

    // Modificar un elemento usando el puntero
    *ptr = 10; // Cambia el valor de arr[1] a 10

    // Imprimir el arreglo modificado
    cout << "Arreglo modificado: ";
    for (int i = 0; i < 5; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}
```

**Salida esperada:**
```
Arreglo original: 1 2 3 4 5 
El valor al que apunta ptr (arr[1]) es: 2
El siguiente elemento es: 3
El elemento anterior es: 1
Arreglo modificado: 1 10 3 4 5 
```

<details><summary>👨‍🏫 Explicación</summary>

Este programa demuestra cómo realizar operaciones básicas con punteros y cómo modificar un arreglo mediante **aritmética de punteros** en **C++**. A continuación, se explican los conceptos clave:

1. **Inicialización del arreglo y del puntero**:
   - `int arr[5] = {1, 2, 3, 4, 5};` define un arreglo de cinco enteros.
   - `int *ptr = arr;` inicializa el puntero `ptr` apuntando al **primer elemento** del arreglo (`arr[0]`).  

2. **Impresión del arreglo original**:
   - Se recorre el arreglo con un `for` y se imprime cada elemento.  

3. **Aritmética de punteros: desplazamiento en memoria**:
   - `ptr++;` mueve el puntero una posición adelante, ahora apunta a `arr[1]` (el valor `2`).  
   - `cout << *ptr;` imprime el valor al que apunta `ptr`, que es `2`.  
   - `*(ptr + 1);` accede al siguiente elemento (`arr[2]`, que es `3`).  
   - `*(ptr - 1);` accede al elemento anterior (`arr[0]`, que es `1`).  

4. **Modificación del arreglo usando el puntero**:
   - `*ptr = 10;` cambia el valor de `arr[1]` de `2` a `10`.  
   - Como `ptr` apunta a `arr[1]`, la modificación se refleja directamente en el arreglo original.  

5. **Impresión del arreglo modificado**:
   - Se recorre nuevamente el arreglo y se imprime su contenido, mostrando el cambio en `arr[1]`.  

En resumen, este programa ilustra cómo los punteros permiten **navegar y modificar un arreglo sin necesidad de índices**, simplemente desplazando el puntero en la memoria.  

</details>  

---

### **Otras operaciones con punteros**  

```cpp
#include <iostream>

using namespace std;

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    int *ptr = arr;

    // Mostrar la dirección inicial y el valor al que apunta
    cout << "Dirección inicial de ptr: " << ptr << " | Valor: " << *ptr << endl;

    // Incrementar un puntero
    ptr++;
    cout << "Después de incrementar, ptr apunta a: " << *ptr << " (Dirección: " << ptr << ")" << endl;

    // Sumar un entero a un puntero
    ptr += 2; // Ahora apunta a arr[3]
    cout << "Después de sumar 2, ptr apunta a: " << *ptr << " (Dirección: " << ptr << ")" << endl;

    // Restar un entero a un puntero
    ptr -= 1; // Ahora apunta a arr[2]
    cout << "Después de restar 1, ptr apunta a: " << *ptr << " (Dirección: " << ptr << ")" << endl;

    // Restar dos punteros
    int *ptr1 = &arr[1];
    int *ptr2 = &arr[4];
    int difference = ptr2 - ptr1; // Diferencia en términos de elementos
    cout << "Diferencia entre ptr2 y ptr1: " << difference << " elementos" << endl;

    return 0;
}
```

**Salida esperada:**  
```
Dirección inicial de ptr: 0x12345678 | Valor: 10
Después de incrementar, ptr apunta a: 20 (Dirección: 0x1234567C)
Después de sumar 2, ptr apunta a: 40 (Dirección: 0x12345684)
Después de restar 1, ptr apunta a: 30 (Dirección: 0x12345680)
Diferencia entre ptr2 y ptr1: 3 elementos
```

> [!NOTE]
>   
> Las direcciones de memoria en la salida son solo un ejemplo, así que no te preocupes si ves algo diferente al ejecutar el código. 😉  


<details><summary>👨‍🏫 Explicación</summary>

Este programa muestra **operaciones básicas con punteros** en C++, como desplazamientos y diferencias entre punteros.

1. **Inicialización del puntero**  
   - `ptr` apunta al primer elemento del arreglo `arr[0]`.

2. **Incremento (`ptr++`)**  
   - Avanza una posición en el arreglo (`arr[1]` → `20`).

3. **Suma (`ptr += 2`)**  
   - Mueve el puntero dos posiciones adelante (`arr[3]` → `40`).

4. **Resta (`ptr -= 1`)**  
   - Retrocede una posición (`arr[2]` → `30`).

5. **Diferencia entre punteros (`ptr2 - ptr1`)**  
   - Calcula cuántos **elementos** separan `arr[1]` y `arr[4]` (3 elementos).

</details>  

---

## 🧩 **Problemas de Punteros Propuestos en C++**  

---

### 🏅 **Problema puntero01: Suma de Elementos con Punteros** | ⚔️ **Guerrero** <!-- omit in toc -->  

🔹 **Descripción:** Dado un arreglo de `n` números, usa **punteros** para calcular la **suma total**.  

📌 **Ejemplo:**  
```
Ingresa la cantidad de números: 4
Número 1: 3
Número 2: 7
Número 3: 2
Número 4: 5
Suma total: 17
```  

> [!TIP]  
> Usa un puntero para recorrer el arreglo y sumar los valores.  

---

### 🏅 **Problema puntero02: Inversión de un Arreglo** | 🔥 **Experto** <!-- omit in toc -->  

🔹 **Descripción:** Dado un arreglo, usa **punteros** para invertir su contenido.  

📌 **Ejemplo:**  
```
Ingresa la cantidad de números: 5
Números originales: 1 2 3 4 5
Números invertidos: 5 4 3 2 1
```  

> [!TIP]  
> Usa dos punteros: uno al inicio y otro al final, intercambiando valores hasta la mitad del arreglo.  

---

### 🏅 **Problema puntero03: Búsqueda en un Arreglo con Punteros** | 👑 **Leyenda** <!-- omit in toc -->  

🔹 **Descripción:** Dado un arreglo y un número a buscar, usa punteros para verificar si el número está presente y en qué posición.  

📌 **Ejemplo:**  
```
Ingresa la cantidad de números: 6
Ingresa los números: 4 8 15 16 23 42
Ingresa el número a buscar: 15
El número 15 se encuentra en la posición 3.
```  

> [!TIP]  
> Usa un puntero para recorrer el arreglo y comparar cada elemento con el número buscado.  

---

# 4. **Referencias**  

Las **referencias** en **C++** permiten crear un alias para una variable existente, lo que significa que cualquier operación sobre la referencia afecta directamente a la variable original.  

> [!NOTE]
>
> Las referencias son una característica nueva en C++ y no existen en C. Fueron introducidas para facilitar la manipulación de variables sin necesidad de punteros, mejorando la legibilidad y seguridad del código.

📌 **Diferencia clave con los punteros:**  
- Una referencia **no puede ser `nullptr`**.  
- Una vez inicializada, **no puede cambiar de objeto** al que hace referencia.  
- Su sintaxis es más sencilla y directa que la de los punteros.  

---

### Sintaxis: <!-- omit in toc -->   

```cpp
tipo &nombreReferencia = variable;
```  

📌 **Explicación:**  
- `tipo`: El tipo de dato de la referencia debe coincidir con el de la variable original.  
- `&nombreReferencia`: Declara una referencia.  
- `variable`: Es la variable a la que hace referencia.  

---

### 🚀 **Ejemplo 1: Referencia a una variable**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int valor = 10;
    int &ref = valor;  // 'ref' es una referencia a 'valor'

    cout << "Valor original: " << valor << endl;
    cout << "Referencia: " << ref << endl;

    ref = 20;  // Cambia el valor de 'valor' a través de la referencia

    cout << "Nuevo valor: " << valor << endl;
    return 0;
}
```  

📌 **Salida:**  
```
Valor original: 10
Referencia: 10
Nuevo valor: 20
```  

<details><summary>👨‍🏫 Explicación</summary>

- `int &ref = valor;` → `ref` se comporta como un alias de `valor`, por lo que cualquier operación sobre `ref` afecta directamente a `valor`.  
- Modificar `ref` **también modifica `valor`**, ya que ambas representan la misma variable en memoria.  

</details>

---

## **Referencias constantes (`const &`)**  

Si no queremos modificar la variable original pero tampoco queremos hacer una copia, podemos usar **referencias constantes**.  

---

### 🚀 **Ejemplo 2: Uso de `const &`**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int valor = 50;
    const int &ref = valor;  // Referencia constante a 'valor'

    cout << "Valor original: " << valor << endl;
    cout << "Referencia constante: " << ref << endl;

    // ref = 100;  // Esto daría error porque 'ref' es constante

    valor = 75;  // Se puede modificar 'valor' directamente

    cout << "Nuevo valor de 'valor': " << valor << endl;
    cout << "La referencia constante refleja el cambio: " << ref << endl;

    return 0;
}
```

📌 **Salida esperada:**  
```
Valor original: 50
Referencia constante: 50
Nuevo valor de 'valor': 75
La referencia constante refleja el cambio: 75
```

<details><summary>👨‍🏫 Explicación</summary>

- `const int &ref = valor;` → `ref` es una **referencia constante**, lo que significa que **no se puede modificar `valor` a través de `ref`**.  
- **Sin embargo**, `valor` **sí puede cambiar**, y como `ref` es solo un alias de `valor`, reflejará el nuevo valor automáticamente.  
- **Intentar hacer `ref = 100;` generaría un error de compilación**, ya que `ref` es constante.  

</details>

---

## **Comparación entre referencias y punteros**  

| Característica | Referencias (`&`) | Punteros (`*`) |
|--------------|----------------|--------------|
| Puede ser `nullptr` | ❌ No | ✅ Sí |
| Puede cambiar de objeto | ❌ No | ✅ Sí |
| Más seguro y fácil de leer | ✅ Sí | ❌ No |
| Necesita `*` para acceder al valor | ❌ No | ✅ Sí |

# 5. **Funciones**

Las funciones permiten reutilizar código dentro de un programa. Una función en **C++** está compuesta por:  

- Tipo de retorno  
- Nombre de la función  
- Lista de parámetros  
- Cuerpo de la función  

```cpp
tipo_retorno nombre_funcion(param1, param2, ...) {
    ...
    cuerpo_de_la_función;
    ...
}
```

### **Ejemplo básico**  

```cpp
#include <iostream>

using namespace std;

// Función para sumar dos números
int sumar(int num1, int num2) {
    return num1 + num2;
}

int main() {
    int a = 5, b = 3;
    int resultado = sumar(a, b);
    cout << "La suma de " << a << " y " << b << " es: " << resultado << endl;
    return 0;
}
```

---

## **Métodos de paso de argumentos**  

> [!NOTE]
> 
> En C++, un **parámetro** es la variable definida en la función para recibir un valor, mientras que un **argumento** es el valor real que se pasa cuando se llama a la función. Es común confundirlos, pero la diferencia clave es que los **parámetros** existen en la **definición** de la función, mientras que los **argumentos** aparecen en la **llamada**. 🚀

En **C++**, los parámetros de una función pueden pasarse de tres maneras:  

### **Paso por valor**  

Este es el método predeterminado. Se pasa una copia del valor del argumento a la función, por lo que **las modificaciones dentro de la función no afectan al argumento original**.  

#### Ejemplo: <!-- omit in toc -->  

```cpp
#include <iostream>

using namespace std;

void intercambiar(int x, int y) {
    int temp = x;
    x = y;
    y = temp;
}

int main() {
    int a = 4, b = 5;
    intercambiar(a, b);
    cout << "Después de la función:\na = " << a << "\nb = " << b << endl;
    return 0;
}
```

**Salida esperada:**  
```
Después de la función:
a = 4
b = 5
```

> [!NOTE]
> 
> Como `x` e `y` son copias, el intercambio **no afecta** a `a` y `b`.
>

---

### **Paso por referencia con punteros**  

Aquí se pasa la dirección de los argumentos a la función usando **punteros**. Esto permite modificar los valores originales.  

#### Ejemplo:  <!-- omit in toc -->  

```cpp
#include <iostream>

using namespace std;

void intercambiar(int* x, int* y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

int main() {
    int a = 4, b = 5;
    intercambiar(&a, &b);
    cout << "Después de la función:\na = " << a << "\nb = " << b << endl;
    return 0;
}
```

**Salida esperada:**  
```
Después de la función:
a = 5
b = 4
```

> [!NOTE]
> 
> Aquí sí se intercambian los valores, ya que se están modificando directamente en memoria.
> 

---

### **Paso por referencia con referencias**  

Este método utiliza **referencias (`&`)** en lugar de punteros, lo que simplifica el código sin perder eficiencia.  

#### Ejemplo:  <!-- omit in toc -->  

```cpp
#include <iostream>

using namespace std;

void intercambiar(int &x, int &y) {
    int temp = x;
    x = y;
    y = temp;
}

int main() {
    int a = 4, b = 5;
    intercambiar(a, b);
    cout << "Después de la función:\na = " << a << "\nb = " << b << endl;
    return 0;
}
```

**Salida esperada:**  
```
Después de la función:
a = 5
b = 4
```
> [!NOTE]
> 
> Al pasar por referencia, `a` y `b` se modifican **sin necesidad de usar punteros**.

---

## 📌 Conclusión <!-- omit in toc -->

| Método | ¿Modifica el valor original? | Complejidad |
|--------|-----------------------------|------------|
| **Por valor (`int x`)** | ❌ No | Baja (se crea una copia) |
| **Por referencia con punteros (`int* x`)** | ✅ Sí | Media (requiere `&` y `*`) |
| **Por referencia con referencias (`int &x`)** | ✅ Sí | Baja (más intuitivo que punteros) |

> [!IMPORTANT]
> 
> Si necesitas proteger el valor original, usa **paso por valor**.  
> Si quieres modificarlo sin copias, usa **paso por referencia (con punteros o referencias)**.  

---
## 🧩 **Problemas de Funciones Propuestos en C++**  

---

### 🏅 **Problema función01: Conversión de Tiempo** | ⏳ **Novato** <!-- omit in toc -->  

🔹 **Descripción:** Crea una función `convertirTiempo` que reciba una cantidad de **segundos** y devuelva su equivalente en **horas, minutos y segundos**.  

📌 **Ejemplo:**  
```
Ingresa los segundos: 3661
Resultado: 1 horas, 1 minutos, 1 segundos
```  

📌 **Nombre de la función:** `convertirTiempo`  
📌 **Lista de parámetros:** `(int segundos, int &horas, int &minutos, int &segundos)`  

> [!TIP]  
> Desglosa el tiempo en partes: los **segundos totales** se pueden dividir para obtener las **horas** y el **resto de segundos**. Luego, haz lo mismo para calcular los **minutos** y los **segundos finales**. Asegúrate de que la función pueda manejar diferentes valores de entrada, incluyendo `0` segundos. 🚀  

---

### 🏅 **Problema función02: Operaciones con Arreglos** | 📊 **Experto** <!-- omit in toc -->  

🔹 **Descripción:** Crea una función `calcularOperaciones` que reciba un **arreglo de números** y devuelva la **suma**, el **promedio** y el **mayor número**.  

📌 **Ejemplo:**  
```
Ingresa la cantidad de números: 4
Números: 10 20 30 40
Suma: 100
Promedio: 25
Mayor: 40
```  

📌 **Nombre de la función:** `calcularOperaciones`  
📌 **Lista de parámetros:** `(int arr[], int n, int &suma, float &promedio, int &mayor)`  

> [!TIP]  
> Usa un `for` para recorrer el arreglo y calcular los valores requeridos en una sola pasada. Ten en cuenta que el primer número leído puede ser el **mayor** temporalmente hasta que encuentres uno más grande. También, asegúrate de manejar casos donde el arreglo tenga solo un número. 🚀  

---

### 🏅 **Problema función03: Cálculo de Interés Compuesto** | 💰 **Maestro** <!-- omit in toc -->  

🔹 **Descripción:** Crea una función `calcularInteresCompuesto` que reciba el **capital inicial**, la **tasa de interés** y los **años**, y calcule el **monto final** aplicando **interés compuesto**.  

📌 **Ejemplo:**  
```
Capital inicial: 1000
Tasa de interés anual: 5%
Años: 3
Monto total: 1157.63
```  

📌 **Nombre de la función:** `calcularInteresCompuesto`  
📌 **Lista de parámetros:** `(double capital, double tasa, int años) -> retorna double`  

> [!TIP]  
> Usa la fórmula `M = C * (1 + r/100)^t` y la función `pow()` de `<cmath>`. 🚀  

---

### 🏅 **Problema función04: Cálculo de Área y Perímetro de un Rectángulo** | 📏 **Leyenda** <!-- omit in toc -->  

🔹 **Descripción:** Crea una función `calcularRectangulo` que reciba el **largo** y **ancho** de un rectángulo y devuelva su **área** y **perímetro**.  

📌 **Ejemplo:**  
```
Largo: 5
Ancho: 3
Área: 15
Perímetro: 16
```  

📌 **Nombre de la función:** `calcularRectangulo`  
📌 **Lista de parámetros:** `(double largo, double ancho, double &area, double &perimetro)`  

> [!TIP]  
> Usa las fórmulas `área = largo * ancho` y `perímetro = 2 * (largo + ancho)`. Asegúrate de probar la función con diferentes valores, incluyendo rectángulos con lados iguales. 🚀  

---

### 🏅 **Problema función05: Cifrado César** | 🔐 **Gran Maestro** <!-- omit in toc -->  

🔹 **Descripción:** Crea una función `cifrarCesar` que reciba una **cadena** y un **desplazamiento `n`** y la cifre usando **Cifrado César**.  

📌 **Ejemplo:**  
```
Texto original: HOLA
Desplazamiento: 3
Texto cifrado: KROD
```  

📌 **Nombre de la función:** `cifrarCesar`  
📌 **Lista de parámetros:** `(string texto, int desplazamiento) -> retorna string`  

> [!TIP]  
> Usa `isalpha(c)` para verificar si un carácter es una letra antes de cifrarlo. Ajusta los valores con `mod 26` para evitar desbordamientos y mantener el cifrado dentro del alfabeto. 🚀  

---

# 6. **Asignación dinámica de memoria en C++**  

La **asignación dinámica de memoria** ocurre cuando se reserva memoria en **tiempo de ejecución** usando una función de la biblioteca estándar. En **C++**, esto se logra con los operadores `new` y `delete`.  

---

## **Asignación de memoria dinámica**  

Para crear objetos dinámicos en C++, se usa la palabra clave **`new`**.  

📌 **Ejemplo 1: Reservar memoria para un solo entero**  

```cpp
int *p = new int;
```

> [!NOTE]
> 
> Esto asigna **memoria sin nombre** para almacenar un valor de tipo `int` y devuelve la dirección de esa memoria.  

📌 **Ejemplo 2: Reservar memoria para un array dinámico**  

```cpp
int *q = new int[128];
```

Esta línea reserva **memoria para un arreglo de 128 elementos de tipo `int`**.  

---

## **Liberación de memoria dinámica**  

Para evitar **fugas de memoria**, es importante liberar la memoria asignada con `delete`.  

> [!NOTE]
> 
> Si no liberas la memoria asignada con `new`, seguirá ocupando espacio incluso cuando ya no la necesites, causando **fugas de memoria**. Esto puede ralentizar el sistema y, en casos extremos, hacer que el programa **colapse**. Siempre que uses `new`, asegúrate de usar `delete` para liberar la memoria. 🚀


📌 **Ejemplo:**  

```cpp
delete p;      // Libera la memoria de un solo entero
delete[] q;    // Libera la memoria de un array dinámico
```

---

## **Ejemplo completo: Promedios de estudiantes (Memoria dinámica)**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int numEstudiantes;

    cout << "Ingrese el número de estudiantes: ";
    cin >> numEstudiantes;

    // Reservar memoria para un array dinámico de promedios
    float *promedios = new float[numEstudiantes];

    // Verificar si la asignación de memoria fue exitosa
    if (!promedios) {
        cerr << "Error: No se pudo asignar memoria.\n";
        return 1;
    }

    // Ingresar los promedios de los estudiantes
    for (int i = 0; i < numEstudiantes; i++) {
        cout << "Promedio del estudiante " << i + 1 << ": ";
        cin >> promedios[i];
    }

    // Imprimir los promedios
    cout << "\nPromedios de los estudiantes:\n";
    for (int i = 0; i < numEstudiantes; i++) {
        cout << "Estudiante " << i + 1 << ": " << promedios[i] << endl;
    }

    // Liberar la memoria asignada dinámicamente
    delete[] promedios;

    return 0;
}
```

<details><summary>👨‍🏫 Explicación</summary>

- Se usa `new float[numEstudiantes]` para **reservar memoria dinámica** y almacenar `numEstudiantes` valores.  
- Se verifica si la asignación fue exitosa para evitar **errores en tiempo de ejecución**.  
- Se capturan e imprimen los promedios ingresados por el usuario.  
- Finalmente, se libera la memoria con `delete[] promedios` para **evitar fugas de memoria**, asegurando un uso eficiente de los recursos.  

</details>

---

## **Versión estática (Tamaño fijo del array)**  

```cpp
#include <iostream>
using namespace std;

#define MAX_ESTUDIANTES 100  // Tamaño máximo del array

int main() {
    int numEstudiantes;
    float promedios[MAX_ESTUDIANTES];

    cout << "Ingrese el número de estudiantes (máximo " << MAX_ESTUDIANTES << "): ";
    cin >> numEstudiantes;

    if (numEstudiantes > MAX_ESTUDIANTES) {
        cout << "El número de estudiantes supera el límite.\n";
        return 1;
    }

    // Ingresar los promedios de los estudiantes
    for (int i = 0; i < numEstudiantes; i++) {
        cout << "Promedio del estudiante " << i + 1 << ": ";
        cin >> promedios[i];
    }

    // Imprimir los promedios
    cout << "\nPromedios de los estudiantes:\n";
    for (int i = 0; i < numEstudiantes; i++) {
        cout << "Estudiante " << i + 1 << ": " << promedios[i] << endl;
    }

    return 0;
}
```

## **Diferencias clave entre memoria dinámica y estática**  <!-- omit in toc -->

| Característica | Memoria Dinámica (`new`) | Memoria Estática (Array fijo) |
|---------------|-------------------------|------------------------------|
| **Tamaño ajustable en ejecución** | ✅ Sí | ❌ No |
| **Eficiencia en uso de memoria** | ✅ Mejor | ❌ Puede desperdiciar espacio |
| **Riesgo de fuga de memoria** | ❌ Sí (si no se usa `delete`) | ✅ No |
| **Velocidad de acceso** | 🔄 Ligeramente más lenta | ⚡ Más rápida |

---

> [!IMPORTANT]
> 
> - Usa **memoria dinámica (`new`)** cuando **no conoces el tamaño exacto** en tiempo de compilación.  
> - Usa **memoria estática (arrays normales)** si el tamaño es fijo y conocido.  
> - **Siempre** libera la memoria con `delete` para evitar **fugas de memoria**. 🚀

# **🧮 Tarea 2 - Reto C++**

[![Unirse a la tarea](https://img.shields.io/badge/%F0%9F%91%89%20Unirse%20a%20la%20tarea%20en%20GitHub%20Classroom-blue?style=for-the-badge)](https://classroom.github.com/a/sHyJsgJf)


## **📢🚨 FECHA LÍMITE: Lunes 17 de febrero - 11:59 PM 🚨📢** <!-- omit in toc -->

⚠️ **ENTREGAS FUERA DE TIEMPO NO SERÁN ACEPTADAS.**  
✅ **Haz `commit` y `push` antes del plazo y verifica tu entrega en GitHub Classroom.**

---

## **📖 Descripción de la Tarea** <!-- omit in toc -->

La tarea consta de **dos problemas** con distinta dificultad y puntaje asignado.

---

## **📌 Problema 1 (40 puntos)** <!-- omit in toc -->

### **Descripción** <!-- omit in toc -->

ONE OK ROCK comenzó su carrera tocando en pequeños clubes y avanzó hasta presentarse en estadios internacionales. Imagina que cada concierto representa un número en su trayectoria, desde el primero hasta el más reciente. Su crecimiento ha sido una historia de esfuerzo y perseverancia, enfrentando desafíos y superando barreras culturales para llegar a audiencias de todo el mundo. Tu tarea es escribir un programa que reciba un número entero positivo **N**, representando la cantidad de conciertos, e imprima en líneas separadas los números del **1** al **N**, simbolizando cada presentación de la banda. Este proceso reflejará la progresión de ONE OK ROCK desde sus humildes inicios hasta sus grandes actuaciones en escenarios internacionales.

Además, puedes imaginar que cada número representa un hito importante en la carrera de la banda, como el lanzamiento de un álbum exitoso, una colaboración destacada o una actuación inolvidable en un festival de renombre.

### **📌 Entrada** <!-- omit in toc -->

- Un solo número entero **N** *(1 ≤ N ≤ 10000)*.

### **📌 Salida** <!-- omit in toc -->

- **N** líneas, cada una con un número del **1** al **N**, representando cada concierto de ONE OK ROCK en su camino al éxito.

### **Ejemplo de Entrada y Salida** <!-- omit in toc -->

### **Ejemplo 1** <!-- omit in toc -->

#### Entrada: <!-- omit in toc -->

```
3
```

#### Salida: <!-- omit in toc -->

```
1
2
3

```

### **Ejemplo 2** <!-- omit in toc -->

#### Entrada: <!-- omit in toc -->

```
7
```

#### Salida: <!-- omit in toc -->

```
1
2
3
4
5
6
7

```

### **📜 Código Base** <!-- omit in toc -->
El siguiente código base debe usarse para resolver este problema.  
⚠️ **No se debe cambiar el nombre del archivo, debe llamarse `punto1.cpp`.**  

```cpp
#include <iostream>

using namespace std;

int main() {
    int n; // Variable para alamacenar la entrada del usuario
    cin >> n; // Lectura de la entrada desde la consola

    // TODO: Implementar la solución para el problema correspondiente

    return 0; // Indica que el programa finalizó correctamente
}
```

---

## **📌 Problema 2 (60 puntos)**  <!-- omit in toc -->

### **📖 Historia**  <!-- omit in toc -->

En una remota academia de criptografía, los estudiantes han descubierto una secuencia numérica con propiedades desconocidas. Se dice que esta serie fue utilizada por una antigua civilización para cifrar mensajes ocultos en textos religiosos y científicos. Sin embargo, los manuscritos solo revelan los primeros dos números y el número total de términos necesarios.  

Tu misión es recrear la secuencia y revelar el número clave que usaban para verificar la autenticidad de los mensajes. Dependiendo de la estructura del mensaje, el número clave podría cambiar su interpretación.  

Los registros indican que esta civilización estableció un límite en la cantidad de términos que podían generarse. **Solo se permitía calcular hasta N = 29**, ya que creían que los números primos eran esenciales en su sistema, y **29 es el mayor número primo menor a 30**. Cualquier cálculo fuera de este rango era considerado inexacto o incluso prohibido en su método de análisis.  

---

### **📜 Reglas de la Serie**  <!-- omit in toc -->

1. Se reciben tres números enteros: **A, B, N**.  
   - **A** y **B** → Son los dos primeros términos de la serie.  
   - **N** → Indica cuántos términos debe generar el sistema.  
2. Cada término de la serie se calcula como la **suma de los dos anteriores**.  
3. El resultado esperado es el **último dígito** del término final.  

### **🎯 Condición Especial**  <!-- omit in toc -->

Las investigaciones sugieren que cuando **N** es un número primo, los antiguos matemáticos no utilizaban el último dígito, sino el **primer dígito** del término final, ya que creían que los números primos tenían propiedades divinas y eran la clave de su código numérico.  

---

## **📌 Entrada**  <!-- omit in toc -->

El programa recibirá **una única línea de entrada** con tres números enteros separados por un espacio:  

- **A** *(1 ≤ A ≤ 10,000)* → Primer número de la serie.  
- **B** *(1 ≤ B ≤ 10,000)* → Segundo número de la serie.  
- **N** *(1 ≤ N ≤ 29)* → Cantidad de términos a generar (limitado por razones estructurales).  

---

## **📌 Salida**  <!-- omit in toc -->

El programa debe imprimir **un único número**:  

- El **último dígito** del término final generado, salvo cuando **N** sea primo, en cuyo caso se imprimirá el **primer dígito**.  

---

### **Ejemplos de Entrada y Salida**  <!-- omit in toc -->

#### **Ejemplo 1** (**N** no es primo)  <!-- omit in toc -->

##### Entrada:  <!-- omit in toc -->
```
1 1 12
```  

##### Salida:  <!-- omit in toc -->
```
4
```  

*(Serie generada: 1 1 2 3 5 8 13 21 34 55 89 144 → Último dígito: 4)*  

---

#### **Ejemplo 2** (**N** es primo) <!-- omit in toc -->  

##### Entrada:  <!-- omit in toc -->
```
130 5 13
```  

##### Salida:  <!-- omit in toc -->
```
1
```  

*(Serie generada: 130 5 135 140 275 415 690 1105 1795 2900 4695 7595 12290 → Primer dígito: 1)*  

---

## **📜 Notas Importantes**  <!-- omit in toc -->

- **El sistema debe manejar números grandes sin desbordarse.**  
- **Se debe optimizar la generación de la serie para evitar un uso excesivo de memoria.**  

---

### **📜 Código Base** <!-- omit in toc -->
El siguiente código base debe usarse para resolver este problema.  
⚠️ **No se debe cambiar el nombre del archivo, debe llamarse `punto2.cpp`.**  

```cpp
#include <iostream>

using namespace std;

// Función para determinar si un número es primo
bool esPrimo(int n) {
    if (n < 2) return false;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) return false;
    }
    return true;
}

// Función para obtener el primer dígito de un número
int primerDigito(int num) {
    // TODO: Implementar la extracción del primer dígito del número
    return 0;
}

// Función para calcular el último dígito del término final de la serie
int calcularUltimoDigito(int a, int b, int n) {
    // TODO: Implementar la generación de la serie y extraer el dígito correspondiente
    return 0;
}

int main() {
    int a, b, n;
    cin >> a >> b >> n; // Lectura de los valores de entrada
    cout << calcularUltimoDigito(a, b, n) << endl; // Cálculo e impresión del resultado
    return 0;
}
```

## **📌 ¿Cómo entregar la tarea en GitHub Classroom?** <!-- omit in toc -->

### **📝 Pasos para entregar tu código correctamente:** <!-- omit in toc -->

## 1️⃣ Aceptar la tarea  <!-- omit in toc -->
1. **Accede al enlace de la tarea:** [https://classroom.github.com/a/sHyJsgJf](https://classroom.github.com/a/sHyJsgJf).
2. **Acepta la tarea** haciendo clic en el botón correspondiente.  
3. Una vez aceptada, **se habrá creado automáticamente un repositorio en GitHub** con la siguiente dirección (reemplaza `TU_USUARIO` con tu nombre de usuario en GitHub):  
   ```
   https://github.com/profesorcito/tarea-2-TU_USUARIO
   ```
   Puedes verificarlo ingresando a tu cuenta de GitHub.  

## 2️⃣ Descargar el repositorio a tu computadora <!-- omit in toc -->  
4. **Abre Git Bash** en tu computadora.  
5. **Navega a la carpeta donde guardarás el proyecto** con el siguiente comando:  
   ```bash
   cd ~/Desktop/CLionProjects
   ```
6. **Clona tu repositorio** en tu computadora** con el siguiente comando (reemplaza `TU_USUARIO` con tu usuario en GitHub):  
   ```bash
   git clone https://github.com/profesorcito/tarea-2-TU_USUARIO.git
   ```

> [!NOTE]
>  
> Si tienes dudas sobre la dirección exacta del repositorio, **puedes copiarla desde GitHub** haciendo clic en el botón verde que dice **"Code"**.
>  
   

## 3️⃣ Abrir el repositorio en CLion <!-- omit in toc -->
7. **Abrir el proyecto en CLion**  
   - Presiona `Alt + F`.  
   - Selecciona **New** → **Project**.  
   - En la parte izquierda, selecciona **C++ Executable**.  
   - Busca la carpeta donde quedó el repositorio dentro de `CLionProjects`.  
   - Debe llamarse:  
     ```
     tarea-2-TU_USUARIO
     ```
   - Haz clic en **Create**.  

> [!IMPORTANT]
>
> Aparecerá un mensaje preguntando si deseas crear el proyecto sobre los archivos existentes. **Debes aceptar.**  Si pregunta si quieres abrirlo en esta ventana, **también acepta.**  
>

## 4️⃣ Modificar y probar el código <!-- omit in toc --> 
8. **Editar y ejecutar `punto1.cpp`:**  
   - Busca `punto1.cpp` y ábrelo.  
   - Escribe el código necesario para resolver el problema.  
   - Antes de compilar, en la parte superior, en el menú desplegable junto al botón **Build** (🔨), **selecciona `punto1`**.  
   - Ejecuta el programa y verifica que la salida sea la esperada.  

9. **Editar y ejecutar `punto2.cpp`:**  
   - Busca `punto2.cpp` y ábrelo.  
   - Escribe el código necesario para resolver el problema.  
   - Antes de compilar, en la parte superior, en el menú desplegable junto al botón **Build** (🔨), **selecciona `punto2`**.  
   - Ejecuta el programa y verifica que la salida sea la esperada.  

## 5️⃣ Subir los cambios a GitHub <!-- omit in toc -->
10. **Guarda los cambios y súbelos a GitHub** con los siguientes comandos:  
   ```bash
   git add .
   git commit -m "Intento 1"
   git push origin master
   ```

## 6️⃣ Verificar la tarea en GitHub Classroom <!-- omit in toc -->  
11. **Revisa en la pestaña "Actions"** de GitHub si tu tarea fue aceptada.  
   - Si tu tarea fue aceptada, **se mostrará en verde** ✅.  
   - Si hubo errores, **se mostrará en rojo** ❌.  
12. Si haces clic en el último commit, puedes acceder a **"run-autograding-test"** para ver qué pruebas no pasaste.  
13. **Corrige el código y sube los cambios nuevamente** usando `git push` hasta que tu evaluación esté en verde.  

---
> [!IMPORTANT]  
>
>- **No cambies el nombre de los archivos (`punto1.cpp` y `punto2.cpp`).**  
>- **Asegúrate de hacer `commit` y `push` antes de la fecha límite.**  
>- **Si encuentras errores en el autograder, revisa tu salida y ajústala según los ejemplos dados.**  
>
---


