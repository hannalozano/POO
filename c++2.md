
---

# üíª 300CIS017 Programaci√≥n Orientada a Objetos 2025-01  <!-- omit in toc -->


---

# üåü Tema 2: El lenguaje C++ - Parte 2 <!-- omit in toc -->

---

En este cap√≠tulo, habiendo comprendido previamente el manejo de versiones con **Git** üßë‚Äçüíª, nos adentraremos en los fundamentos del lenguaje **C++** üíª. A lo largo de esta secci√≥n, aprenderemos a estructurar programas, manejar tipos de datos, usar operadores, implementar estructuras de control y ciclos para crear soluciones eficientes. Tambi√©n exploraremos temas m√°s avanzados como el manejo de memoria din√°mica, el uso de punteros y la creaci√≥n de funciones y estructuras. üöÄ

### **Tabla de Contenido**

- [Iteration Statements](#iteration-statements)
  - [The for-loop statement](#the-for-loop-statement)
  - [The while-loop statement](#the-while-loop-statement)
  - [The do-while-loop statement](#the-do-while-loop-statement)
  - [With a for-loop statement:](#with-a-for-loop-statement)
  - [With a while-loop statement:](#with-a-while-loop-statement)
  - [With a do-while-loop statement:](#with-a-do-while-loop-statement)
  - [Nested Loops](#nested-loops)
  - [Break and Continue](#break-and-continue)
  - [Arrays](#arrays)
  - [Pointers](#pointers)
  - [Arithmetic of Pointers](#arithmetic-of-pointers)
    - [Basic Pointer Arithmetic Operations](#basic-pointer-arithmetic-operations)
  - [Functions](#functions)
  - [Argument Passing Methods](#argument-passing-methods)
  - [Dynamic Memory Allocation](#dynamic-memory-allocation)
    - [Static Version](#static-version)
  - [Structures](#structures)
- [Structures](#structures-1)
- [Files](#files)
  - [Banco.c](#bancoc)



## Iteration Statements

There are three types of iteration statements, which are informally known as loops:

### The for-loop statement
```c
for(init-statement; condition; expression) {
    loop-statement-1;
    loop-statement-2;
    ...
}
```

### The while-loop statement
```c
while(condition) {
    loop-statement-1;
    loop-statement-2;
    ...
}
```

### The do-while-loop statement
```c
do {
    loop-statement-1;
    loop-statement-2;
    ...
} while(condition);
```

To see how they work, let us use all three of them for the same purpose, namely to compute `‚àë(i=1)^n i` (s = 1 + 2 + 3 + ... + n).

### With a for-loop statement:
```c
#include <stdio.h>

int main() {
    int s = 0, i, n;
    printf("Enter n: ");
    scanf("%d", &n);

    for(i = 1; i <= n; i++) 
        s += i;

    printf("suma=%d\n", s);
    return 0;
}
```

### With a while-loop statement:
```c
#include <stdio.h>

int main() {
    int s = 0, i, n;
    printf("Enter n: ");
    scanf("%d", &n);

    i = 1;
    while(i <= n) {
        s += i;
        i++;
    }

    printf("suma=%d\n", s);
    return 0;
}
```

### With a do-while-loop statement:
```c
#include <stdio.h>

int main() {
    int s = 0, i, n;
    printf("Enter n: ");
    scanf("%d", &n);

    i = 1;
    do {
        s += i;
        i++;
    } while(i <= n);

    printf("suma=%d\n", s);
    return 0;
}
```

As you see there are not major differences among them. However, the for-loop statement should be used when we know what the range of the loop is going to be. Otherwise we should use a while-loop or do-while-loop statement.

### Nested Loops

Let's take a look at an example of nested loops:

```c
#include <stdio.h>

int main() {
    int i, j, n;
    printf("Enter the size of the pattern: ");
    scanf("%d", &n);

    for(i = 1; i <= n; i++) {
        for(j = 1; j <= i; j++) {
            printf("*");
        }
        printf("\n");
    }

    return 0;
}
```

This code will generate a pattern of stars that looks like this if n is `5`:
```
*
**
***
****
*****
```

Here is the content starting from slide 26 converted to Markdown, ignoring the footer:

---

### Break and Continue

- `break`: causes an immediate exit from a loop.

```c
#include <stdio.h>

int main() {
    double s = 0.0, x;
    printf("Enter numbers, separated by blanks.\n");
    printf("They are added up as long as they are positive.\n");

    for (;;) { // Example of a forever-loop
        scanf("%lf", &x);
        if (x <= 0) break;
        s += x;
    }

    printf("Sum of the positive numbers that have been read: %lf", s);
    return 0;
}
```

- `continue`: causes an immediate jump to the test for the continuation of the loop.

```c
#include <stdio.h>

int main() {
    int i;

    for(i = 1; i <= 10; i++) {
        if(i == 5) continue;
        printf("%d\n", i);
    }

    printf("Used continue to skip the printing of value 5\n");
    return 0;
}
```

### Arrays

The use of arrays permits us to manipulate a group of memory locations as a single entity, but at the same time gives us direct access to any individual component. Arrays are simple examples of structured data types.

- Declaring an array: The general syntax for an array declaration is: `type array-name[size-d1][size-d2] ...;`

Example:

```c
#include <stdio.h>

int main() {
    int i, a[10];

    for(i = 0; i < 10; i++) {
        printf("a[%d]= ", i + 1);
        scanf("%d", &a[i]);
    }

    printf("The same integers, in reverse order: ");
    for(i = 9; i >= 0; i--)
        printf("%d ", a[i]);

    return 0;
}
```

- Initializing an array:

Examples:

```c
int a[2][3] = { { 1,2,3 }, { 4,5,6 } };
int b[2][3] = { 1,2,3,4,5 };
int c[2][3] = { { 1,2 }, { 4 } };
```

Values of `a` by row:
```
1 2 3
4 5 6
```

Values of `b` by row:
```
1 2 3
4 5 0
```

Values of `c` by row:
```
1 2 0
4 0 0
```

```c
#include <stdio.h>

int main() {
    int i, j;
    int a[2][3] = { { 1,2,3 }, { 4,5,6 } };
    int b[2][3] = { 1,2,3,4,5 };
    int c[2][3] = { { 1,2 }, { 4 } };

    printf("Array a:\n");
    for(i = 0; i < 2; i++) {
        for(j = 0; j < 3; j++)
            printf("%4d ", a[i][j]);
        printf("\n");
    }

    printf("Array b:\n");
    for(i = 0; i < 2; i++) {
        for(j = 0; j < 3; j++)
            printf("%4d ", b[i][j]);
        printf("\n");
    }

    printf("Array c:\n");
    for(i = 0; i < 2; i++) {
        for(j = 0; j < 3; j++)
            printf("%4d ", c[i][j]);
        printf("\n");
    }

    return 0;
}
```

### Pointers

Variables that contain a memory address as its value. There are two important pointer operators:

- `&` (address of): returns the address of the object given by the operand
- `*` (dereference): returns the object that has the address given by the operand

Example:

```c
#include <stdio.h>

int main() {
    int i = 16;
    int *pi;
    pi = &i;
    printf("%d\n", *pi);
    return 0;
}
```

### Arithmetic of Pointers

In C, pointers can be used in arithmetic expressions. This arithmetic is not just simple addition or subtraction; it takes into account the size of the data type the pointer is pointing to.

#### Basic Pointer Arithmetic Operations

1. **Incrementing a Pointer:**
    - When you increment a pointer, it actually moves to the next element of the type it points to.
    - For example, if `ptr` is an `int` pointer, `ptr++` will make it point to the next integer (which is `ptr + sizeof(int)`).

    ```c
    int arr[5] = {1, 2, 3, 4, 5};
    int *ptr = arr;
    ptr++; // Now ptr points to arr[1]
    ```

###Full Example <!-- omit in toc -->

```c
#include <stdio.h>

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    int *ptr = arr;

    ptr++; // Ahora ptr apunta a arr[1]

    printf("El valor al que apunta ptr (arr[1]) es: %d\n", *ptr);

    // Acceder a otros elementos usando aritm√©tica de punteros
    printf("El siguiente elemento es: %d\n", *(ptr + 1)); // Equivalente a arr[2]
    printf("El elemento anterior es: %d\n", *(ptr - 1)); // Equivalente a arr[0]

    // Modificar un elemento usando el puntero
    *ptr = 10; // Cambia el valor de arr[1] a 10

    // Imprimir el arreglo modificado
    for (int i = 0; i < 5; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}
```


2. **Decrementing a Pointer:**
    - Similar to incrementing, decrementing a pointer moves it to the previous element of the type it points to.
    - For example, if `ptr` is an `int` pointer, `ptr--` will make it point to the previous integer (which is `ptr - sizeof(int)`).

    ```c
    ptr--; // Now ptr points back to arr[0]
    ```

3. **Adding an Integer to a Pointer:**
    - Adding an integer to a pointer moves it forward by that number of elements.
    - For example, if `ptr` is an `int` pointer, `ptr + 3` will make it point to the element 3 positions ahead (which is `ptr + 3 * sizeof(int)`).

    ```c
    int *newPtr = ptr + 3; // Points to arr[3]
    ```

4. **Subtracting an Integer from a Pointer:**
    - Subtracting an integer from a pointer moves it backward by that number of elements.
    - For example, if `ptr` is an `int` pointer, `ptr - 2` will make it point to the element 2 positions behind (which is `ptr - 2 * sizeof(int)`).

    ```c
    newPtr = ptr - 2; // Points to arr[0]
    ```

5. **Subtracting Two Pointers:**
    - Subtracting two pointers that point to elements of the same array gives the number of elements between them.
    - For example, if `ptr1` and `ptr2` are `int` pointers pointing to elements of the same array, `ptr2 - ptr1` gives the number of `int` elements between them.

    ```c
    int *ptr1 = &arr[1];
    int *ptr2 = &arr[4];
    int difference = ptr2 - ptr1; // difference is 3
    ```

#### Example Program <!-- omit in toc -->

```c
#include <stdio.h>

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    int *ptr = arr;

    // Initial pointer
    printf("Initial value: %d\n", *ptr);

    // Increment pointer
    ptr++;
    printf("After increment: %d\n", *ptr);

    // Add integer to pointer
    ptr = ptr + 2;
    printf("After adding 2: %d\n", *ptr);

    // Subtract integer from pointer
    ptr = ptr - 1;
    printf("After subtracting 1: %d\n", *ptr);

    // Subtract two pointers
    int *ptr1 = &arr[1];
    int *ptr2 = &arr[4];
    int diff = ptr2 - ptr1;
    printf("Difference between ptr2 and ptr1: %d\n", diff);

    return 0;
}
```

### Functions

User-defined operations to facilitate the reuse of code within programs. A function consists of:

- return type
- function name
- list of parameters
- body

```c
return-type function-name(para1, para2, ...) {
    ...
    body-of-the-function;
    ...
}
```

#### Example <!-- omit in toc -->

```c
#include <stdio.h>

// Function to calculate the sum of two numbers
int add(int num1, int num2) {
  int sum = num1 + num2;
  return sum;
}

int main() {
  int a = 5, b = 3;
  int result = add(a, b);
  printf("The sum of %d and %d is: %d\n", a, b, result);
  return 0;
}
```

### Argument Passing Methods

**Passing by Value**

This is the default method. A copy of the arguments is made and passed to the corresponding parameters. The values of the arguments do not change.

Example:

```c
#include <stdio.h>

void swap(int x, int y) {
    int temp;
    temp = x; x = y; y = temp;
    return;
}

int main() {
    int a = 4, b = 5;
    swap(a, b);
    printf("a=%d\nb=%d\n", a, b);
    return 0;
}
```

**Passing by Reference**

The parameters receive the address of the arguments rather than a copy of its value. The values of the arguments do change.

Example:

```c
#include <stdio.h>

void swap(int* x, int* y) {
    int temp;
    temp = *x; *x = *y; *y = temp;
    return;
}

int main() {
    int a = 4, b = 5;
    swap(&a, &b);
    printf("a=%d\nb=%d\n", a, b);
    return 0;
}
```

### Dynamic Memory Allocation

When the allocation is done by a run-time library invoked during program execution.

- Allocation of dynamic objects: Using the keyword `malloc`

Example 1:

```c
int *p = malloc(sizeof(int));
```

`malloc` will allocate unnamed memory of type `int` and will return the address where the allocation was done.

Example 2:

```c
int *q = malloc(128 * sizeof(int));
```

This line will allocate memory for an array of 128 elements of type `int`.

- Deallocation of dynamic objects: Using the keyword `free`.

Example:

```c
free(p);
free(q);
```

#### Full Examle <!-- omit in toc -->

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int numStudents;

    printf("Enter the number of students: ");
    scanf("%d", &numStudents);

    // Allocate memory for an array of floats (averages)
    float *averages = (float *)malloc(numStudents * sizeof(float));

    // Check if memory allocation was successful
    if (averages == NULL) {
        printf("Error: Could not allocate memory.\n");
        return 1;
    }

    // Get the averages of each student
    for (int i = 0; i < numStudents; i++) {
        printf("Average of student %d: ", i + 1);
        scanf("%f", &averages[i]);
    }

    // Print the averages of the students
    printf("\nStudent averages:\n");
    for (int i = 0; i < numStudents; i++) {
        printf("Student %d: %.2f\n", i + 1, averages[i]);
    }

    // Free the allocated memory
    free(averages);

    return 0;
}
```

#### Static Version

The static version of the above program is as follows:

```c
#include <stdio.h>

#define MAX_STUDENTS 100 // Maximum size of the array

int main() {
    int numStudents;
    float averages[MAX_STUDENTS];

    printf("Enter the number of students (maximum %d): ", MAX_STUDENTS);
    scanf("%d", &numStudents);

    if (numStudents > MAX_STUDENTS) {
        printf("Number of students exceeds the limit.\n");
        return 1;
    }

    // Get the averages of each student
    for (int i = 0; i < numStudents; i++) {
        printf("Average of student %d: ", i + 1);
        scanf("%f", &averages[i]);
    }

    // Print the averages of the students
    printf("\nStudent averages:\n");
    for (int i = 0; i < numStudents; i++) {
        printf("Student %d: %.2f\n", i + 1, averages[i]);
    }

    return 0;
}
```

### Structures

A structure is a collection of one or more variables.

### Example 1: <!-- omit in toc -->

```c
#include <stdio.h>

int main() {
    struct point {
        int x;
        int y;
    };

    struct point p1 = {-1, 4}, p2 = {1, 5}, p3;

    p3.x = 3;
    p3.y = 6;

    printf("point 1 = (%d, %d)\n", p1.x, p1.y); // point 1 = (-1, 4)
    printf("point 2 = (%d, %d)\n", p2.x, p2.y); // point 2 = (1, 5)
    printf("point 3 = (%d, %d)\n", p3.x, p3.y); // point 3 = (3, 6)

    return 0;
}
```

### Example 2: <!-- omit in toc -->

```c
#include <stdio.h>

struct cat {
    int age;
    int height;
    char name[20];
    char father[20];
    char mother[20];
};

int main() {
    struct cat myCat;

    printf("Enter the name of the cat: ");
    scanf("%s", myCat.name);

    printf("How old is %s? ", myCat.name);
    scanf("%d", &myCat.age);

    printf("How high is %s (in hands)? ", myCat.name);
    scanf("%d", &myCat.height);

    printf("Who is %s‚Äôs father? ", myCat.name);
    scanf("%s", myCat.father);

    printf("Who is %s‚Äôs mother? ", myCat.name);
    scanf("%s", myCat.mother);

    printf("\n%s is %d years old, %d hands high,", myCat.name, myCat.age, myCat.height);
    printf(" and has %s and %s as parents.\n", myCat.father, myCat.mother);

    return 0;
}
```

## Structures

### Example 1 <!-- omit in toc -->
```c
#include <stdio.h>

struct point {
    int x;
    int y;
};

int main() {
    struct point p1 = {-1, 4}, p2 = {1, 5}, p3;

    p3.x = 3;
    p3.y = 6;

    printf("point 1 = (%d, %d)\n", p1.x, p1.y);  // point 1 = (-1, 4)
    printf("point 2 = (%d, %d)\n", p2.x, p2.y);  // point 2 = (1, 5)
    printf("point 3 = (%d, %d)\n", p3.x, p3.y);  // point 3 = (3, 6)

    return 0;
}
```

### Example 2 <!-- omit in toc -->
```c
#include <stdio.h>

struct cat {
    int age;
    int height;
    char name[20];
    char father[20];
    char mother[20];
};

int main() {
    struct cat myCat;

    printf("Enter the name of the cat: ");
    scanf("%s", myCat.name);

    printf("How old is %s? ", myCat.name);
    scanf("%d", &myCat.age);

    printf("How high is %s (in hands)? ", myCat.name);
    scanf("%d", &myCat.height);

    printf("Who is %s‚Äôs father? ", myCat.name);
    scanf("%s", myCat.father);

    printf("Who is %s‚Äôs mother? ", myCat.name);
    scanf("%s", myCat.mother);

    printf("\n%s is %d years old, %d hands high,", myCat.name, myCat.age, myCat.height);
    printf(" and has %s and %s as parents.\n", myCat.father, myCat.mother);

    return 0;
}
```

## Files

In C, we can use the function `fopen` to open a file, and `fprintf` to write to it.

### Example <!-- omit in toc -->
```c
#include <stdio.h>

int main() {
    FILE *f;
    int i;

    srand(time(NULL));
    f = fopen("data.txt", "w");

    for (i = 0; i < 100; i++) {
        fprintf(f, "%10d\n", rand() % 10000);
    }

    fclose(f);

    return 0;
}
```

### Other modes in which `fopen` can operate: <!-- omit in toc -->
- `"r"` reading (file must exist)
- `"w"` writing (creates new file and overwrites if already exists)
- `"a"` appending (creates if does not exist)
- `"r+"` reading/writing (file must exist)
- `"w+"` reading/writing (creates new file)
- `"a+"` reading/appending

`fopen` returns `NULL` if the file cannot be opened.

### Reading from a file <!-- omit in toc -->
We can use `fscanf` to read from a file.

### Example <!-- omit in toc -->
```c
#include <stdio.h>

int main() {
    FILE *f;
    int x;

    f = fopen("data.txt", "r");

    while (!feof(f)) {
        fscanf(f, "%10d", &x);
        printf("%10d\n", x);
    }

    fclose(f);

    return 0;
}
```
### Banco.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define CAP 100
#define NAME_LEN 10

typedef struct {
    char name[NAME_LEN];
    int balance;
} Cliente;

void menu() {
    printf("\n=============================\n");
    printf("          BANK MENU          \n");
    printf("=============================\n");
    printf("1. Add Client\n");
    printf("2. Search Client\n");
    printf("3. Delete Client\n");
    printf("4. List Clients\n");
    printf("5. Deposit\n");
    printf("6. Withdraw\n");
    printf("7. Report\n");
    printf("8. Total Balance\n");
    printf("0. Exit\n");
    printf("=============================\n");
    printf("Option: ");
}

void addCliente(Cliente *a, int *n) {
    if (*n >= CAP) {
        printf("Maximum capacity reached.\n");
        return;
    }
    printf("\nEnter client name (max %d characters): ", NAME_LEN - 1);
    scanf("%9s", a[*n].name);
    printf("Enter initial balance: ");
    scanf("%d", &a[*n].balance);
    (*n)++;
    printf("Client added successfully!\n");
}

void searchCliente(Cliente *a, int n) {
    char name[NAME_LEN];
    printf("\nEnter client name to search: ");
    scanf("%9s", name);
    for (int i = 0; i < n; i++) {
        if (strcmp(name, a[i].name) == 0) {
            printf("Client found!\n");
            printf("Name: %s, Balance: %d\n", a[i].name, a[i].balance);
            return;
        }
    }
    printf("Client %s not found.\n", name);
}

void deleteCliente(Cliente *a, int *n) {
    char name[NAME_LEN];
    printf("\nEnter client name to delete: ");
    scanf("%9s", name);
    for (int i = 0; i < *n; i++) {
        if (strcmp(name, a[i].name) == 0) {
            for (int j = i; j < *n - 1; j++) {
                a[j] = a[j + 1];
            }
            (*n)--;
            printf("Client %s deleted successfully.\n", name);
            return;
        }
    }
    printf("Client %s not found.\n", name);
}

void listClientes(Cliente *a, int n) {
    printf("\nClient List:\n");
    printf("==================\n");
    for (int i = 0; i < n; i++) {
        printf("%-10s | %d\n", a[i].name, a[i].balance);
    }
    printf("==================\n");
}

void deposit(Cliente *a, int n) {
    char name[NAME_LEN];
    int amount;
    printf("\nEnter client name to deposit to: ");
    scanf("%9s", name);
    for (int i = 0; i < n; i++) {
        if (strcmp(name, a[i].name) == 0) {
            printf("Enter amount to deposit: ");
            scanf("%d", &amount);
            a[i].balance += amount;
            printf("Deposited %d to %s successfully!\n", amount, name);
            return;
        }
    }
    printf("Client %s not found.\n", name);
}

void withdraw(Cliente *a, int n) {
    char name[NAME_LEN];
    int amount;
    printf("\nEnter client name to withdraw from: ");
    scanf("%9s", name);
    for (int i = 0; i < n; i++) {
        if (strcmp(name, a[i].name) == 0) {
            printf("Enter amount to withdraw: ");
            scanf("%d", &amount);
            a[i].balance -= amount;
            printf("Withdrew %d from %s successfully!\n", amount, name);
            return;
        }
    }
    printf("Client %s not found.\n", name);
}

void report(Cliente *a, int n) {
    Cliente temp;
    FILE *f = fopen("report.txt", "w");
    if (!f) {
        perror("Failed to open report file");
        return;
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n - 1; j++) {
            if (a[j].balance > a[j + 1].balance) {
                temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
            }
        }
    }

    fprintf(f, "NAME       BALANCE\n");
    fprintf(f, "========== ========\n");
    for (int i = 0; i < n; i++) {
        fprintf(f, "%-10s %-8d\n", a[i].name, a[i].balance);
    }
    fclose(f);
   printf("Report generated successfully and saved to report.txt!\n");
}

void totalBalance(Cliente *a, int n) {
    int total = 0;
    for (int i = 0; i < n; i++) {
        total += a[i].balance;
    }
    printf("\nTotal balance of all clients: %d\n", total);
}

void loadClientes(Cliente *a, int *n, const char *filename) {
    FILE *f = fopen(filename, "rb");
    if (!f) {
        perror("Failed to open file");
        return;
    }
    fread(n, sizeof(int), 1, f);
    fread(a, sizeof(Cliente), *n, f);
    fclose(f);
}

void saveClientes(Cliente *a, int n, const char *filename) {
    FILE *f = fopen(filename, "wb");
    if (!f) {
        perror("Failed to open file");
        return;
    }
    fwrite(&n, sizeof(int), 1, f);
    fwrite(a, sizeof(Cliente), n, f);
    fclose(f);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s [filename]\n", argv[0]);
        return 0;
    }

    Cliente a[CAP];
    int n = 0;
    int opc;

    loadClientes(a, &n, argv[1]);

    do {
        menu();
        scanf("%d", &opc);
        switch (opc) {
            case 1:
                addCliente(a, &n);
                break;
            case 2:
                searchCliente(a, n);
                break;
            case 3:
                deleteCliente(a, &n);
                break;
            case 4:
                listClientes(a, n);
                break;
            case 5:
                deposit(a, n);
                break;
            case 6:
                withdraw(a, n);
                break;
            case 7:
                report(a, n);
                break;
            case 8:
                totalBalance(a, n);
                break;
            case 0:
                saveClientes(a, n, argv[1]);
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid option, try again.\n");
        }
    } while (opc != 0);

    return 0;
}
```